\section{Background}
Last semester, we designed and implemented Felix: a system which measures
network traffic using NetKAT. Felix's query language and query compilation
design were complete, and a paper on Felix was accepted to SOSR. However,
both Felix and the SOSR submission were imperfect. First, Felix's query
compiler was slow for large inputs and would often crash on \emph{very} large
inputs. Second, the Felix compiler was not integrated with Haoxian's runtime
which made it onerous to run Felix end-to-end. Finally, our SOSR submission was
written hurriedly and submitted last minute\footnote{literally!}, leaving the
paper a bit incohesive.

\section{Getting Felix Camera-Ready}
The bulk of this semester was spent fixing these imperfections. We optimized
the Felix compiler, integrated the compiler with the runtime, conducted new
benchmarks and case studies, revised the paper, and ultimately presented Felix
at SOSR!

\subsection{Optimization}
\newcommand{\netauto}{\texttt{netkat-automata}}
\paragraph{Hashconsing}
The Felix compiler uses the FDD implementation in the \netauto{} repository
which hashconses NetKAT terms to avoid redundant storage and computation.
However, a couple of performance critical pieces of code did not take advantage
of the hashconsing. Notably, the computation of a term's hash was recomputing
the hash of all of its subterms! When compiling against very large topologies,
this became a bottleneck. We refactored the code to take advantage of
hashconsing which improved the performance of the compiler considerably.
Moreover, we replaced the \netauto{} implementation of hashconsing with an
optimized library implementation.
% https://github.com/backtracking/ocaml-hashcons

\paragraph{CPS}
Our SOSR submission included some Felix benchmarks run against every topology
in the Topology Zoo. Well, almost. A footnote in the paper explained that Felix
crashed on a few of the larger topology. After some debugging, we found that a
certain recursive function was overflowing the stack. We rewrote the function
using CPS and were then able to run on all of Topology Zoo!

\paragraph{Predicate Splitting}
% rene:    splitting up predicates and compiling them separately

\subsection{Integration}
% brandon + jake: integrating with Haoxian
We integrated our query language compiler with Haoxian's end-host measurement
system. The query language compiler output an E-matrix of $(\alpha, \beta)$
pairs. We converted these pairs to configurations for the end-host monitors. We
worked with Haoxian to extend the end-host measurement system to allow packet
tagging. To tag packets, we assigned each $\alpha$ a unique identifier to tag
packets that matched $\alpha$. For each $(\alpha, \beta)$ pair, we configured
all end hosts to count a received packet if it matched $\beta$ and was tagged
with the identifier corresponding to $\alpha$.  We were also able to use this
system to generate traffic matrices since Haoxian's measurement system already
supported keeping track of counts of source-destination pairs.

\subsection{Experimentation}
% ?: talk about all the benchmarks and integration and stuff we did

\subsection{Revision}
% anyone: talk about how we rewrote the paper, but mention it was mostly nate

\subsection{Presentation}
% michael

\section{Budding Ideas}
% ???; whoever was at these meetings:
%   - detecting cycles and black holes
%   - checking counts with minimal instrumentation

\section{Integrating Code}
% michael
\paragaph{What's Done}
\paragaph{What's Left}
